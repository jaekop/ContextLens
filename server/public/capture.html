<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Vision Capture</title>
  <style>
    body { font-family: system-ui, sans-serif; margin: 16px; color: #1c1c1c; }
    .wrap { display: flex; gap: 16px; align-items: flex-start; }
    video { width: 320px; height: 240px; background: #111; border-radius: 8px; }
    .status { margin-top: 8px; font-size: 12px; color: #555; }
    .panel { flex: 1; min-width: 260px; }
    .card { border: 1px solid #e6e6e6; border-radius: 8px; padding: 10px 12px; margin-bottom: 12px; background: #fafafa; }
    .title { font-weight: 600; margin-bottom: 6px; }
    .row { display: flex; gap: 8px; flex-wrap: wrap; font-size: 13px; }
    .pill { background: #111; color: #fff; padding: 2px 8px; border-radius: 999px; font-size: 12px; }
    .muted { color: #777; font-size: 12px; }
    pre { margin: 0; white-space: pre-wrap; font-size: 12px; background: #111; color: #f1f1f1; padding: 10px; border-radius: 8px; }
  </style>
</head>
<body>
  <h1>Vision Capture</h1>
  <div class="wrap">
    <div>
      <video id="video" autoplay muted playsinline></video>
      <div class="status" id="status">Waiting for camera permission...</div>
    </div>
    <div class="panel">
      <div class="card">
        <div class="title">Snapshot Summary</div>
        <div class="row" id="summaryPills">
          <span class="pill">No snapshot yet</span>
        </div>
        <div class="muted" id="summaryMeta">Waiting for first snapshot...</div>
      </div>
      <div class="card">
        <div class="title">Details</div>
        <pre id="visionJson">No vision snapshot yet.</pre>
      </div>
    </div>
  </div>
  <script>
    const statusEl = document.getElementById('status');
    const video = document.getElementById('video');
    const summaryPills = document.getElementById('summaryPills');
    const summaryMeta = document.getElementById('summaryMeta');
    const visionJson = document.getElementById('visionJson');
    let streamReady = false;

    async function init() {
      try {
        const stream = await navigator.mediaDevices.getUserMedia({ video: true, audio: false });
        video.srcObject = stream;
        await new Promise((resolve) => {
          video.onloadedmetadata = () => resolve();
        });
        streamReady = true;
        window.__captureReady = true;
        statusEl.textContent = 'Camera ready.';
      } catch (err) {
        window.__captureError = String(err);
        statusEl.textContent = 'Camera permission denied or unavailable.';
      }
    }

    async function captureAndSend() {
      if (!streamReady) {
        statusEl.textContent = 'Camera not ready.';
        return false;
      }
      if (video.readyState < 2) {
        console.log('video not ready', video.readyState);
        return false;
      }
      const canvas = document.createElement('canvas');
      const maxWidth = 640;
      const maxHeight = 360;
      const vw = video.videoWidth || 320;
      const vh = video.videoHeight || 240;
      console.log('capture dims', vw, vh);
      const scale = Math.min(maxWidth / vw, maxHeight / vh, 1);
      canvas.width = Math.max(1, Math.round(vw * scale));
      canvas.height = Math.max(1, Math.round(vh * scale));
      const ctx = canvas.getContext('2d');
      ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
      const blob = await new Promise((resolve) => canvas.toBlob(resolve, 'image/jpeg', 0.8));
      if (!blob) {
        console.log('blob null');
        return false;
      }
      const buffer = await blob.arrayBuffer();
      const bytes = new Uint8Array(buffer);
      let binary = '';
      for (let i = 0; i < bytes.length; i++) {
        binary += String.fromCharCode(bytes[i]);
      }
      const image_base64 = btoa(binary);
      try {
        const targetUrl = new URL('/frame', window.location.href).toString();
        console.log('posting frame to', targetUrl);
        const res = await fetch(targetUrl, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ image_base64, mime: 'image/jpeg' })
        });
        if (!res.ok) {
          console.log('frame post failed', res.status);
          statusEl.textContent = 'Failed to send frame.';
          return false;
        }
        statusEl.textContent = 'Frame sent at ' + new Date().toLocaleTimeString();
        return true;
      } catch (err) {
        console.log('frame post error', String(err));
        statusEl.textContent = 'Failed to send frame.';
        return false;
      }
    }

    window.captureAndSend = captureAndSend;
    init();
    function renderPills(pairs) {
      summaryPills.innerHTML = '';
      if (!pairs.length) {
        summaryPills.innerHTML = '<span class="pill">No snapshot yet</span>';
        return;
      }
      for (const text of pairs) {
        const span = document.createElement('span');
        span.className = 'pill';
        span.textContent = text;
        summaryPills.appendChild(span);
      }
    }

    async function pollVision() {
      try {
        const res = await fetch('/vision');
        if (!res.ok) return;
        const snap = await res.json();
        if (snap?.error) {
          renderPills([]);
          summaryMeta.textContent = snap.error;
          visionJson.textContent = 'No vision snapshot yet.';
          return;
        }
        const pills = [];
        if (snap.environment?.label) {
          pills.push(`env: ${snap.environment.label}`);
        }
        if (snap.environment?.lighting?.level) {
          pills.push(`light: ${snap.environment.lighting.level}`);
        }
        if (snap.people?.count_estimate !== undefined) {
          pills.push(`people: ${snap.people.count_estimate}`);
        }
        if (snap.social_cues?.interaction_context?.label) {
          pills.push(`context: ${snap.social_cues.interaction_context.label}`);
        }
        if (snap.environment?.objects?.length) {
          pills.push(`objects: ${snap.environment.objects.slice(0, 4).join(', ')}`);
        }
        renderPills(pills);
        summaryMeta.textContent = `Updated: ${new Date(snap.ts_ms || Date.now()).toLocaleTimeString()}`;
        visionJson.textContent = JSON.stringify(snap, null, 2);
      } catch (err) {}
    }
    setInterval(pollVision, 1000);
  </script>
</body>
</html>
